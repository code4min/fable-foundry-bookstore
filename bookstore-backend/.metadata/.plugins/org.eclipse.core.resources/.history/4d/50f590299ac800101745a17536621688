package com.bookstore.controller;

import com.bookstore.dto.ChatRequest;
import com.bookstore.model.Book;
import com.bookstore.model.Category;
import com.bookstore.service.BookService;
import com.bookstore.service.GeminiService;
import com.bookstore.repository.CategoryRepository;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.*;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/ai")
@CrossOrigin(origins = "http://localhost:3000")
public class AiChatController {

    private final GeminiService geminiService;
    private final BookService bookService;
    private final CategoryRepository categoryRepository;

    @Autowired
    public AiChatController(GeminiService geminiService, BookService bookService, CategoryRepository categoryRepository) {
        this.geminiService = geminiService;
        this.bookService = bookService;
        this.categoryRepository = categoryRepository;
    }

    // Rich synonym -> category name map (use your real category names)
    private static final Map<String, String> SYNONYM_TO_CATEGORY;
    static {
        Map<String,String> m = new HashMap<>();

        // Fantasy (category name in DB: "Fantasy")
        m.put("fantasy", "Fantasy");
        m.put("magic", "Fantasy");
        m.put("dragons", "Fantasy");
        m.put("wizard", "Fantasy");
        m.put("wizards", "Fantasy");
        m.put("epic", "Fantasy");
        m.put("sword", "Fantasy");
        m.put("sorcery", "Fantasy");
        m.put("myth", "Fantasy");
        m.put("mythical", "Fantasy");
        m.put("magic academy", "Fantasy");
        m.put("magic school", "Fantasy");

        // Romance (category name in DB: "Romance")
        m.put("romance", "Romance");
        m.put("romantic", "Romance");
        m.put("love story", "Romance");
        m.put("heart", "Romance");
        m.put("relationship", "Romance");
        m.put("slow-burn", "Romance");
        m.put("love", "Romance");

        // Thriller (category name in DB: "Thriller")
        m.put("thriller", "Thriller");
        m.put("suspense", "Thriller");
        m.put("mystery", "Thriller");
        m.put("crime", "Thriller");
        m.put("detective", "Thriller");
        m.put("murder", "Thriller");
        m.put("psychological", "Thriller");
        m.put("suspenseful", "Thriller");
        m.put("spooky", "Thriller");

        // Danmei (category name in DB: "Danmei")
        m.put("danmei", "Danmei");
        m.put("bl", "Danmei");
        m.put("boys love", "Danmei");
        m.put("boys-love", "Danmei");
        m.put("ceo/bl", "Danmei");

        // Self-Help (category name in DB: "Self-Help")
        m.put("self-help", "Self-Help");
        m.put("self help", "Self-Help");
        m.put("motivation", "Self-Help");
        m.put("self improvement", "Self-Help");
        m.put("habits", "Self-Help");
        m.put("productivity", "Self-Help");
        m.put("mindset", "Self-Help");

        // Non-Fiction (category name in DB: "Non-Fiction")
        m.put("non-fiction", "Non-Fiction");
        m.put("non fiction", "Non-Fiction");
        m.put("biography", "Non-Fiction");
        m.put("history", "Non-Fiction");
        m.put("true story", "Non-Fiction");
        m.put("real life", "Non-Fiction");

        // Fiction (category name in DB: "Fiction") -- fallback & synonyms
        m.put("fiction", "Fiction");
        m.put("novel", "Fiction");
        m.put("story", "Fiction");
        m.put("book", "Fiction");
        m.put("read", "Fiction");
        m.put("recommend", "Fiction"); // generic recommend -> fallback to Fiction later
        m.put("suggest", "Fiction");   // same

        SYNONYM_TO_CATEGORY = Collections.unmodifiableMap(m);
    }

    // A small set of phrases to detect "recommendation intent"
    private static final List<String> RECOMMEND_TRIGGERS = Arrays.asList(
            "recommend", "suggest", "give me", "any good", "what should i read", "something to read", "recommendation"
    );

    @PostMapping(value = "/chat", consumes = "application/json", produces = "text/plain")
    public String chat(@RequestBody ChatRequest request) {

        String userMessage = Optional.ofNullable(request).map(ChatRequest::getMessage).orElse("").trim();
        if (userMessage.isEmpty()) {
            return "Please write a message.";
        }

        String lower = userMessage.toLowerCase();

        // 1) Recommendation Intent Detection
        boolean wantsRecommendation = RECOMMEND_TRIGGERS.stream().anyMatch(lower::contains);

        if (wantsRecommendation) {
            // try to detect a specific category keyword in the message
            String detectedCategoryName = detectCategoryFromText(lower);

            if (detectedCategoryName == null) {
                // No specific category found → use Fiction (fallback)
                detectedCategoryName = "Fiction";
            }

            // find category entity
            Optional<Category> categoryOpt = categoryRepository.findByNameIgnoreCase(detectedCategoryName);

            if (categoryOpt.isPresent()) {
                Long catId = categoryOpt.get().getId();
                List<Book> recs = bookService.recommendByCategory(catId);

                if (recs == null || recs.isEmpty()) {
                    // If no books in that category, return friendly message
                    return String.format("I would love to recommend some %s reads, but we don't have titles in that category right now. Would you like me to suggest popular picks instead?", detectedCategoryName);
                }

                // Build a rich conversational reply (titles only, friendly)
                StringBuilder reply = new StringBuilder();
                reply.append(String.format("Absolutely — here are some %s picks from Fable Foundry that I think you'll enjoy:\n\n", detectedCategoryName));

                // Limit to first 6 to keep reply concise
                recs.stream().limit(6).forEach(b -> {
                    reply.append("• ").append(b.getTitle());
                    if (b.getAuthor() != null && !b.getAuthor().isEmpty()) {
                        reply.append(" — ").append(b.getAuthor());
                    }
                    reply.append("\n");
                });

                reply.append("\nWould you like me to show details for any of these?");
                return reply.toString();
            } else {
                // Category not found in DB
                return "I can recommend books, but I couldn't find that genre in our categories. Would you like some popular picks from Fable Foundry instead?";
            }
        }

        // 2) Try searching the inventory for title/author matches
        List<Book> found = bookService.searchByTitleOrAuthor(lower);

        if (!found.isEmpty()) {
            // Build availability-style replies (no counts/prices — just friendly availability)
            StringBuilder reply = new StringBuilder();
            reply.append("I found these titles in Fable Foundry:\n\n");

            found.stream().limit(8).forEach(b -> {
                reply.append("• ").append(b.getTitle());
                if (b.getAuthor() != null && !b.getAuthor().isEmpty()) {
                    reply.append(" — ").append(b.getAuthor());
                }
                reply.append(" — ").append(b.getStock() > 0 ? "Available" : "Out of stock");
                reply.append("\n");
            });

            reply.append("\nWould you like me to add any of these to your cart or show more details?");
            return reply.toString();
        }

        // 3) Nothing matched locally → ask Gemini, but send DB context (none found)
        String dbContext = "No matching books found in the Fable Foundry inventory for the user's query.";
        return geminiService.generateResponse(userMessage, dbContext);
    }

    /**
     * Detect category name by scanning for known synonyms in the user's text.
     * Returns the normalized category name (as stored in DB) or null if none matched.
     */
    private String detectCategoryFromText(String lowerText) {
        // Check multi-word keys first (longer keys) to catch phrases like "self help" or "boys love"
        List<String> keys = new ArrayList<>(SYNONYM_TO_CATEGORY.keySet());
        // sort by length descending so multi-word synonyms are matched before single words
        keys.sort((a, b) -> Integer.compare(b.length(), a.length()));

        for (String key : keys) {
            if (lowerText.contains(key)) {
                return SYNONYM_TO_CATEGORY.get(key);
            }
        }
        return null;
    }
}
