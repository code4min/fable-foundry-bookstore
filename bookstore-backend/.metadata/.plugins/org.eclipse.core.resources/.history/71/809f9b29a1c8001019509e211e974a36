package com.bookstore.controller;

import com.bookstore.dto.ChatRequest;
import com.bookstore.model.Book;
import com.bookstore.model.Category;
import com.bookstore.service.BookService;
import com.bookstore.service.GeminiService;
import com.bookstore.repository.CategoryRepository;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.*;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/ai")
@CrossOrigin(origins = "http://localhost:3000")
public class AiChatController {

    private final GeminiService geminiService;
    private final BookService bookService;
    private final CategoryRepository categoryRepository;

    @Autowired
    public AiChatController(GeminiService geminiService, BookService bookService, CategoryRepository categoryRepository) {
        this.geminiService = geminiService;
        this.bookService = bookService;
        this.categoryRepository = categoryRepository;
    }

    // Synonym → Category map (cleaned + improved)
    private static final Map<String, String> SYNONYM_TO_CATEGORY;
    static {
        Map<String,String> m = new HashMap<>();

        // Fantasy
        m.put("fantasy", "Fantasy");
        m.put("magic", "Fantasy");
        m.put("dragons", "Fantasy");
        m.put("wizard", "Fantasy");
        m.put("wizards", "Fantasy");
        m.put("epic", "Fantasy");
        m.put("myth", "Fantasy");
        m.put("mythical", "Fantasy");

        // Romance
        m.put("romance", "Romance");
        m.put("romantic", "Romance");
        m.put("love story", "Romance");
        m.put("slow-burn", "Romance");
        m.put("love", "Romance");

        // Thriller
        m.put("thriller", "Thriller");
        m.put("mystery", "Thriller");
        m.put("detective", "Thriller");
        m.put("crime", "Thriller");
        m.put("psychological", "Thriller");

        // Danmei (improved multi-word handling)
        m.put("danmei", "Danmei");
        m.put("bl", "Danmei");
        m.put("bl novel", "Danmei");
        m.put("bl novels", "Danmei");
        m.put("boys love", "Danmei");
        m.put("boys-love", "Danmei");
        m.put("danmei novels", "Danmei");
        m.put("danmei books", "Danmei");

        // Self-Help
        m.put("self-help", "Self-Help");
        m.put("self help", "Self-Help");
        m.put("motivation", "Self-Help");
        m.put("self improvement", "Self-Help");

        // Non-Fiction
        m.put("non-fiction", "Non-Fiction");
        m.put("biography", "Non-Fiction");
        m.put("history", "Non-Fiction");

        // Fiction (fallback)
        m.put("fiction", "Fiction");
        m.put("novel", "Fiction");
        m.put("story", "Fiction");

        SYNONYM_TO_CATEGORY = Collections.unmodifiableMap(m);
    }

    // Triggers for recommendation intent (NOT used in category detection)
    private static final List<String> RECOMMEND_TRIGGERS = Arrays.asList(
            "recommend", "suggest", "give me", "any good", "what should i read",
            "something to read", "recommendation", "reading suggestion"
    );

    @PostMapping(value = "/chat", consumes = "application/json", produces = "text/plain")
    public String chat(@RequestBody ChatRequest request) {

        String userMessage = Optional.ofNullable(request).map(ChatRequest::getMessage).orElse("").trim();
        if (userMessage.isEmpty()) {
            return "Please write a message.";
        }

        String lower = userMessage.toLowerCase();

        // 1) Detect intent to recommend
        boolean wantsRecommendation = RECOMMEND_TRIGGERS.stream().anyMatch(lower::contains);

        if (wantsRecommendation) {

            // 1.5) Detect category from synonyms
            String detectedCategory = detectCategoryFromText(lower);

            if (detectedCategory == null) {
                detectedCategory = "Fiction"; // fallback
            }

            Optional<Category> categoryOpt = categoryRepository.findByNameIgnoreCase(detectedCategory);

            if (categoryOpt.isPresent()) {
                Long catId = categoryOpt.get().getId();
                List<Book> recs = bookService.recommendByCategory(catId);

                if (recs == null || recs.isEmpty()) {
                    return "I'd love to recommend some " + detectedCategory +
                           " reads, but we don't have titles in that category right now.";
                }

                StringBuilder reply = new StringBuilder();
                reply.append("Here are some " + detectedCategory + " picks from Fable Foundry:\n\n");

                recs.stream().limit(6).forEach(b -> {
                    reply.append("• ").append(b.getTitle());
                    if (b.getAuthor() != null && !b.getAuthor().isEmpty()) {
                        reply.append(" — ").append(b.getAuthor());
                    }
                    reply.append("\n");
                });

                reply.append("\nWant details on any of these?");
                return reply.toString();
            } else {
                return "I can recommend books, but I couldn’t find that genre in our categories.";
            }
        }

        // 2) Availability search by title/author
        String cleaned = extractCleanTitle(lower);

        List<Book> found = bookService.searchByTitleOrAuthor(cleaned);

        if (!found.isEmpty()) {
            StringBuilder reply = new StringBuilder();
            reply.append("I found these titles in Fable Foundry:\n\n");

            found.stream().limit(8).forEach(b -> {
                reply.append("• ").append(b.getTitle());
                if (b.getAuthor() != null && !b.getAuthor().isEmpty()) {
                    reply.append(" — ").append(b.getAuthor());
                }
                reply.append(" — ")
                     .append(b.getStock() > 0 ? "Available" : "Out of stock");
                reply.append("\n");
            });

            reply.append("\nWould you like me to add any to your cart?");
            return reply.toString();
        }


        if (!found.isEmpty()) {
            StringBuilder reply = new StringBuilder();
            reply.append("I found these titles in Fable Foundry:\n\n");

            found.stream().limit(8).forEach(b -> {
                reply.append("• ").append(b.getTitle());
                if (b.getAuthor() != null && !b.getAuthor().isEmpty()) {
                    reply.append(" — ").append(b.getAuthor());
                }
                reply.append(" — ").append(b.getStock() > 0 ? "Available" : "Out of stock");
                reply.append("\n");
            });

            reply.append("\nWould you like me to add any to your cart?");
            return reply.toString();
        }

        // 3) Nothing matched — ask Gemini with DB context
        String dbContext = "No matching books found in Fable Foundry inventory.";
        return geminiService.generateResponse(userMessage, dbContext);
    }

    /**
     * Detects category by scanning synonyms.
     * IMPORTANT: Removes intent triggers from category detection.
     */
    private String detectCategoryFromText(String lowerText) {

        List<String> keys = new ArrayList<>(SYNONYM_TO_CATEGORY.keySet());
        keys.sort((a, b) -> Integer.compare(b.length(), a.length())); // longest first

        for (String key : keys) {
            if (lowerText.contains(key)) {
                return SYNONYM_TO_CATEGORY.get(key);
            }
        }
        return null;
    }
    
    
    private String extractCleanTitle(String text) {
        if (text == null) return "";

        // Remove question marks, punctuation
        text = text.replaceAll("[^a-zA-Z0-9\\s]", "");

        // Remove common filler words
        text = text.replaceAll("\\b(is|the|a|an|do|does|can|please|tell me|if|about|available)\\b", " ");

        // Collapse spaces
        text = text.replaceAll("\\s+", " ").trim();

        return text;
    }

}
